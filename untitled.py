# -*- coding: utf-8 -*-
# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PIL import Image
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import *
from PyQt5.QtCore import QStringListModel

class Ui_Dialog(object):
    def __init__(self):
        global dict1
        dict1 = {}
        global images
        images = {}
        self.updatePhoto()
        print("程序入口：__init__")

    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.setFixedSize(900, 570)

        self.readRules()
        # 规则库文本定位
        self.rule_label = QtWidgets.QLabel(Dialog)
        self.rule_label.setGeometry(QtCore.QRect(20, 30, 54, 12))
        self.rule_label.setObjectName("rule_label")
        # 规则库数据框定位
        self.rule_listView = QtWidgets.QListView(Dialog)
        self.rule_listView.setGeometry(QtCore.QRect(20, 60, 256, 192))
        self.rule_listView.setObjectName("rule_listView")
        # 条件库文本定位
        self.condition_label = QtWidgets.QLabel(Dialog)
        self.condition_label.setGeometry(QtCore.QRect(20, 270, 54, 12))
        self.condition_label.setObjectName("condition_label")
        # 条件库数据框定位
        self.condition_listView = QtWidgets.QListView(Dialog)
        self.condition_listView.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.condition_listView.setGeometry(QtCore.QRect(20, 300, 256, 192))
        self.condition_listView.setObjectName("condition_listView")
        # 清空条件按钮定位
        self.add_condition = QtWidgets.QPushButton(Dialog)
        self.add_condition.setGeometry(QtCore.QRect(20, 510, 256, 31))
        self.add_condition.setObjectName("add_condition")
        # 用户添加条件格式按钮定位
        self.input_rules = QtWidgets.QPushButton(Dialog)
        self.input_rules.setGeometry(QtCore.QRect(310, 60, 260, 30))
        self.input_rules.setObjectName("input_rules")
        # 用户添加条件文本定位
        self.lable1 = QtWidgets.QLabel(Dialog)
        self.lable1.setGeometry(QtCore.QRect(310, 100, 61, 31))
        self.lable1.setObjectName("lable1")
        # 用户添加条件框定位
        self.user_conditions = QtWidgets.QLineEdit(Dialog)
        self.user_conditions.setGeometry(QtCore.QRect(350, 100, 221, 31))
        self.user_conditions.setObjectName("user_conditions")
        # 用户添加结果文本定位
        self.label_4 = QtWidgets.QLabel(Dialog)
        self.label_4.setGeometry(QtCore.QRect(310, 150, 54, 12))
        self.label_4.setObjectName("label_4")
        # 用户添加结果框定位
        self.result = QtWidgets.QLineEdit(Dialog)
        self.result.setGeometry(QtCore.QRect(350, 140, 221, 31))
        self.result.setObjectName("result")
        # 用户添加图片文本定位
        self.label_7 = QtWidgets.QLabel(Dialog)
        self.label_7.setGeometry(QtCore.QRect(310, 190, 54, 12))
        self.label_7.setObjectName("label_7")
        # 用户添加图片框定位
        self.photo = QtWidgets.QLineEdit(Dialog)
        self.photo.setFocusPolicy(QtCore.Qt.NoFocus)  # 设置不可编辑
        self.photo.setGeometry(QtCore.QRect(350, 180, 221, 31))
        self.photo.setObjectName("photo")
        # 用户上传图片按钮
        self.user_img = QtWidgets.QPushButton(Dialog)
        self.user_img.setGeometry(QtCore.QRect(350, 220, 85, 30))
        self.user_img.setObjectName("user_img")
        # 更新按钮定位
        self.update_rules = QtWidgets.QPushButton(Dialog)
        self.update_rules.setGeometry(QtCore.QRect(483, 220, 85, 30))
        self.update_rules.setObjectName("update_rules")
        # 当前使用规则文本定位
        self.label_5 = QtWidgets.QLabel(Dialog)
        self.label_5.setGeometry(QtCore.QRect(310, 270, 91, 21))
        self.label_5.setObjectName("label_5")
        # 当前使用规则框定位
        self.current_rules = QtWidgets.QListView(Dialog)
        self.current_rules.setGeometry(QtCore.QRect(310, 300, 261, 191))
        self.current_rules.setObjectName("current_rules")
        # 图片显示定位
        self.image = QtWidgets.QLabel(Dialog)
        self.image.setGeometry(QtCore.QRect(600, 60, 271, 281))
        self.image.setObjectName("image")
        # 推理结果文本定位
        self.label_6 = QtWidgets.QLabel(Dialog)
        self.label_6.setGeometry(QtCore.QRect(610, 380, 81, 41))
        self.label_6.setObjectName("label_6")
        # 推理结果框定位
        self.inference_result = QtWidgets.QTextEdit(Dialog)
        self.inference_result.setGeometry(QtCore.QRect(670, 385, 190, 31))
        self.inference_result.setObjectName("inference_result")
        # 推理按钮定位
        self.reasoning = QtWidgets.QPushButton(Dialog)
        self.reasoning.setGeometry(QtCore.QRect(630, 450, 91, 41))
        self.reasoning.setObjectName("reasoning")
        # 取消按钮定位
        self.cancel = QtWidgets.QPushButton(Dialog)
        self.cancel.setGeometry(QtCore.QRect(780, 450, 81, 41))
        self.cancel.setObjectName("cancel")
        # 弹出窗口设置
        layout = QVBoxLayout()
        layout.addWidget(self.update_rules)
        self.setLayout(layout)

        self.updateStorehouse(list=list2)
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        print("界面设计：setupUi")

    # 清空推理结果数据
    def cancel1(self):
        self.inference_result.setPlainText("")
        current_rule = QStringListModel()  # 创建mode
        current_rule.setStringList([])  # 将数据设置到model
        self.current_rules.setModel(current_rule)
        pix = QtGui.QPixmap("images/" + images["空"])
        self.image.setScaledContents(True)
        self.image.setPixmap(pix)

    # 界面文本设置
    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "推理系统"))
        self.rule_label.setText(_translate("Dialog", "规则库:"))
        self.condition_label.setText(_translate("Dialog", "条件库"))
        self.add_condition.setText(_translate("Dialog", "清空条件"))
        self.lable1.setText(_translate("Dialog", "条件"))
        self.label_4.setText(_translate("Dialog", "结果"))
        self.label_7.setText(_translate("Dialog", "图片"))
        self.user_img.setText(_translate("Dialog", "上传图片"))
        self.update_rules.setText(_translate("Dialog", "更新规则"))
        self.label_5.setText(_translate("Dialog", "当前使用规则"))
        self.label_6.setText(_translate("Dialog", "推理结果"))
        self.input_rules.setText(_translate("Dialog", "用户输入格式要求介绍"))
        self.reasoning.setText(_translate("Dialog", "自动推理"))
        self.cancel.setText(_translate("Dialog", "取消"))
        # 点击事件设置
        self.reasoning.clicked.connect(self.reasoning1)
        self.update_rules.clicked.connect(self.update1)
        self.add_condition.clicked.connect(self.clear_rule)
        self.cancel.clicked.connect(self.cancel1)
        self.rule_listView.clicked.connect(self.clickedlist)
        self.current_rules.clicked.connect(self.clickedPhoto)
        self.user_img.clicked.connect(self.getImage)
        self.input_rules.clicked.connect(self.show2)
        print("文本设计：retranslateUi")

    # 清空条件库
    def clear_rule(self):
        list4 = []
        condition = QStringListModel()  # 创建mode
        condition.setStringList(list4)  # 将数据设置到model
        self.condition_listView.setModel(condition)
        print("条件库初始化：clear_rule")
        self.readRules()
        self.updateStorehouse(list2)

    # 选择本地图片上传
    def getImage(self):
        global imgName
        # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型
        imgName, imgType = QFileDialog.getOpenFileName(self.user_img, "打开图片", "",
                                                       "*.jpeg;;*.jpg;;*.png")
        # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽
        img = QtGui.QPixmap(imgName).scaled(self.image.width(), self.image.height())
        self.image.setPixmap(img)
        self.photo.setText(imgName.split('/')[-1])

    # 保存图片到本地
    def saveImage(self):
        img = Image.open(imgName)
        img_name = imgName.split('/')[-1]
        img.save('images/' + img_name)

    # 规则库内容修改
    def updateStorehouse(self, list):
        slm = QStringListModel()  # 创建mode
        slm.setStringList(list)  # 将数据设置到model
        self.rule_listView.setModel(slm)  ##绑定 listView 和 model

    # 规则库内容添加
    def update1(self):
        str = self.user_conditions.text()
        str1 = self.result.text()
        imgName = self.photo.text()
        if len(str.split(' ')) != 7 or len(str1.split(' ')) != 1:
            self.show1()
            return
        elif len(imgName) == 0:
            self.show3()
            return
        filepath = r'.\txt\animal.txt'
        fo = open(filepath, "a", encoding="utf-8")
        fo.write(str + " ")
        fo.write(str1 + "\n")
        fo.close()
        self.readRules()
        self.saveImage()
        filepath = r'.\txt\photo_txt.txt'
        fo = open(filepath, "a", encoding="utf-8")
        fo.write(str1 + " ")
        fo.write(imgName + "\n")
        fo.close()
        print(images)
        slm = QStringListModel()  # 创建mode
        slm.setStringList(list2)  # 将数据设置到model
        self.rule_listView.setModel(slm)  ##绑定 listView 和 model
        self.updatePhoto()
        print("修改数据：update1")

    # 选择特征打印
    def clickedlist(self, qModelIndex):
        list4.append(list2[qModelIndex.row()])
        condition = QStringListModel()  # 创建mode
        condition.setStringList(list4)  # 将数据设置到model
        self.condition_listView.setModel(condition)
        self.clickedlist2()
        print("点击的是：" + str(qModelIndex.row()))

    # 消除同类特征
    def clickedlist2(self):
        for t in range(len(list1) - 1):
            temp1 = []
            flag = False
            for tt in dict1.keys():
                temp1.append(list(dict1[tt])[t])
                if list(dict1[tt])[t] in list4:
                    flag = True
            if flag:
                for t in range(0, len(temp1)):
                    if temp1[t] in list2:
                        list2.remove(temp1[t])
        self.updateStorehouse(list2)

    # 图片显示设置
    def setPhoto(self, string):
        current_rule = QStringListModel()  # 创建mode
        current_rule.setStringList(result)  # 将数据设置到model
        self.current_rules.setModel(current_rule)
        pix = QtGui.QPixmap("images/" + images[string])
        self.image.setScaledContents(True)
        self.image.setPixmap(pix)

    # 修改图片
    def clickedPhoto(self, qModelIndex):
        photo = result[qModelIndex.row()]
        self.inference_result.setPlainText(photo)
        self.setPhoto(photo)

    # 特征分类并导入
    def readRules(self):
        global list1, list2, list4
        list4 = []
        filepath = r'.\txt\animal.txt'
        fo = open(filepath, "r", encoding="utf-8")
        global dict1
        temp_list1, temp_list2 = [], []
        # 逐行读取文件
        for line in fo.readlines():
            if line.strip() == '':
                continue
            # 分割为单词
            list1 = line.split()
            # 以"结果:特征"的方式存入字典dict1
            dict1[list1[-1]] = list1[0:-1]
        fo.close()
        # 将特征点按分类顺序存入临时列表temp_list
        for t in range(len(list1) - 1):
            for tt in dict1.keys():
                temp_list1.append(list(dict1[tt])[t])

        # 去除重复特征并保留顺序
        list2 = list(set(temp_list1))
        list2.sort(key=temp_list1.index)
        print("数据导入：readRules")

    # 物种推理
    def reasoning1(self):
        global dict1
        global list4
        print(list4)
        dict1, dict2 = {}, {}
        filepath = r'.\txt\animal.txt'
        fo = open(filepath, "r", encoding="utf-8")
        # 逐行读取文件
        for line in fo.readlines():
            if line.strip() == '':
                continue
            # 分割为单词
            list1 = line.split()
            # 以"个体名:特征"的方式存入字典dict1
            dict1[list1[-1]] = list1[0:-1]
        fo.close()
        print("dict1")
        print(dict1)
        global result
        result = []
        for i in dict1.keys():
            flag = True
            for j in list4:
                if j not in dict1.get(i):
                    flag = False
                    break
            if flag:
                result.append(i)
        print(result)

        if len(result) > 0:
            self.inference_result.setPlainText(result[0])
            self.setPhoto(result[0])
        else:
            self.inference_result.setPlainText("无符合对象！")
            self.setPhoto("空")

    # 更新图片文本
    def updatePhoto(self):
        global images
        images = {}
        filepath = r'.\txt\photo_txt.txt'
        fo = open(filepath, "r", encoding="utf-8")
        photo = []
        # 逐行读取文件
        for line in fo.readlines():
            if line.strip() == '':
                continue
            # 分割为单词
            photo = line.split()
            images[photo[0]] = photo[1]
        fo.close()

    def show1(self):
        reply = QMessageBox.warning(self, "错误提示框", "输入条件或结果有误！请重新输入。",
                                    QMessageBox.Yes | QMessageBox.No,
                                    QMessageBox.Yes)

    def show2(self):
        reply = QMessageBox.about(self, "格式介绍", "请按照身体构造、头部特征、物种特点、体型、体色、食性、个体特点的顺序填写，\n"
                                                    "并以空格分隔开,上传图片不能为空。\n"
                                                    "例如：\n"
                                                    "   条件：1 2 3 4 5 6 7\n"
                                                    "   结果：1\n"
                                                    "   图片：图片名.jpeg")

    def show3(self):
        reply = QMessageBox.warning(self, "错误提示框", "图片未上传！", QMessageBox.Yes | QMessageBox.No,
                                    QMessageBox.Yes)
